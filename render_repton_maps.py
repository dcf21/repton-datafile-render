#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# render_repton_maps.py
#
# Produce maps and sprite charts from data files generated by the BBC Micro and
# Electron versions of Repton 3 and Repton Infinity.
#
# Copyright (C) 2023 Dominic Ford <https://dcford.org.uk/>
#
# This code is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# You should have received a copy of the GNU General Public License along with
# this file; if not, write to the Free Software Foundation, Inc., 51 Franklin
# Street, Fifth Floor, Boston, MA  02110-1301, USA

# ----------------------------------------------------------------------------

"""
Produce maps and sprite charts from data files generated by the BBC Micro and
Electron versions of Repton 3 and Repton Infinity.

This script is compatible with the BBC Micro and Electron versions of
Repton 3 and Repton Infinity, but not with data files produced by / for other
platforms.

References:

https://www.reptonresourcepage.co.uk/Downloads/Items/DecodingRepton.pdf
"""

import argparse
import copy
import logging
import sys

from math import ceil, floor
from matplotlib import font_manager
from PIL import Image, ImageDraw, ImageFont
from typing import List, Optional, Tuple

# RGB components for each of the BBC Micro's eight colours
bbc_micro_colours = [(0, 0, 0), (255, 0, 0), (0, 255, 0), (255, 255, 0),
                     (0, 0, 255), (255, 0, 255), (0, 255, 255), (255, 255, 255)]

# Default logical colour palette to use when no other is available
default_colour_palette: List[Tuple[int, int, int]] = [(0, 0, 0), (0, 0, 255), (0, 255, 0), (0, 255, 255),
                                                      (128, 128, 128)]

# Default Repton Infinity sprite set to use when none other is available
default_repton_infinity_sprites = \
    "/mnt/ganymede4/dcf21/floppy_disks/elk_floppies_v4_unzipped/elk06/repinf/REPINFIN/eS/Rep3"

# Data structure defining the layout of all Repton Infinity's various flavours of data file
repton_infinity_file_structure = {
    "eG": {
        "encrypted": True,
        "level_count": 4,
        "sprites_start": 0,
        "sprite_dimensions": (8, 16),
        "map_sprites_start": 0x1150,
        "map_sprite_dimensions": (4, 8),
        "default_colours_start": None,
        "levels_start": 0x950
    },
    "G": {
        "encrypted": True,
        "level_count": 4,
        "sprites_start": 0,
        "sprite_dimensions": (16, 32),
        "map_sprites_start": 0x2350,
        "map_sprite_dimensions": (4, 8),
        "default_colours_start": None,
        "levels_start": 0x1B50
    },
    "eM": {
        "encrypted": False,
        "level_count": 4,
        "sprites_start": None,
        "map_sprites_start": None,
        "default_colours_start": None,
        "levels_start": 0x10
    },
    "M": {
        "encrypted": False,
        "level_count": 4,
        "sprites_start": None,
        "map_sprites_start": None,
        "default_colours_start": None,
        "levels_start": 0x10
    },
    "eS": {
        "encrypted": False,
        "level_count": 0,
        "sprites_start": 0x114,
        "sprite_dimensions": (8, 16),
        "map_sprites_start": 0x014,
        "map_sprite_dimensions": (4, 8),
        "default_colours_start": 0,
        "levels_start": None
    },
    "S": {
        "encrypted": False,
        "level_count": 0,
        "sprites_start": 0x114,
        "sprite_dimensions": (16, 32),
        "map_sprites_start": 0x014,
        "map_sprite_dimensions": (4, 8),
        "default_colours_start": 0,
        "levels_start": None
    },
    "E": {
        "encrypted": False,
        "level_count": 0,
        "sprites_start": 0,
        "sprite_dimensions": (8, 8),
        "map_sprites_start": None,
        "default_colours_start": None,
        "levels_start": None,
        "square_pixels": True
    },
    "eE": {
        "encrypted": False,
        "level_count": 0,
        "sprites_start": 0,
        "sprite_dimensions": (8, 8),
        "map_sprites_start": None,
        "default_colours_start": None,
        "levels_start": None,
        "square_pixels": True
    }
}


class ReptonSprite:
    """
    Representation of a single Repton sprite.
    """

    def __init__(self, x_size: int, y_size: int):
        """
        Representation of a single Repton sprite.

        :param x_size:
            Horizontal size of the sprite
        :param y_size:
            Vertical size of the sprite
        """
        self.x_size: int = x_size
        self.y_size: int = y_size

        # Colour to use if a border is drawn around the sprite
        self.border_value = 4

        # Initialise the sprite to zeros
        self.sprite_data: List[List[int]] = [[0 for x in range(x_size)] for y in range(y_size)]

    def get_pixel(self, x_pos: int, y_pos: int) -> int:
        """
        Fetch a pixel from the sprite. Return the border value if the queried pixel lies outside the sprite.

        :param x_pos:
            Position of pixel to query.
        :param y_pos:
            Position of pixel to query.
        :return:
            Logical colour of the pixel (0-3)
        """
        if (0 <= x_pos < self.x_size) and (0 <= y_pos < self.y_size):
            return self.sprite_data[y_pos][x_pos]
        else:
            return self.border_value

    @classmethod
    def from_bytes(cls, x_size: int, y_size: int,
                   input_bytes: bytes, start_position: int = 0):
        """
        Fetch a single sprite from binary data.

        :param x_size:
            Horizontal size of the sprite
        :param y_size:
            Vertical size of the sprite
        :param input_bytes:
            Binary data stream
        :param start_position:
            The byte position of the start of the sprite we are to fetch
        :return:
            A ReptonSprite instance
        """

        # Create a sprite object to read the binary data into
        output = cls(x_size=x_size, y_size=y_size)
        pos_min: int = start_position
        sprite_size_bytes: int = output.sprite_size_bytes()

        # All versions of Repton use MODE 5 graphics, with four colours
        bit_depth: int = 2
        bytes_per_line: int = x_size * bit_depth

        # Iterate through the input binary data
        for pos in range(sprite_size_bytes):
            # Each byte encodes four pixels of sprite data, encoding in the same way as BBC Micro screen memory
            v = input_bytes[pos_min + pos]

            pos_y = floor(pos / bytes_per_line) * 8 + (pos % 8)
            pos_x_row = floor((pos % bytes_per_line) / 8)
            pixels_per_byte = int(8 / bit_depth)
            pos_x = int(pos_x_row * pixels_per_byte)

            output.sprite_data[pos_y][pos_x + 3] = ((v & 0x01) >> 0) + ((v & 0x10) >> 3)
            output.sprite_data[pos_y][pos_x + 2] = ((v & 0x02) >> 1) + ((v & 0x20) >> 4)
            output.sprite_data[pos_y][pos_x + 1] = ((v & 0x04) >> 2) + ((v & 0x40) >> 5)
            output.sprite_data[pos_y][pos_x + 0] = ((v & 0x08) >> 3) + ((v & 0x80) >> 6)

        return output

    def sprite_size_bytes(self) -> int:
        """
        Return the number of bytes needed to encode this sprite in a binary data file.

        :return:
            Number of bytes
        """
        return int(self.x_size * self.y_size / 4)

    def print_sprite_ascii(self, border_size=1) -> str:
        """
        Return a crude representation of this sprite in ASCII text.

        :param border_size:
            The size of the border to place around the sprite
        :return:
            ASCII string
        """
        output: str = ""
        for y in range(-border_size, self.y_size + border_size):
            for x in range(-border_size, self.x_size + border_size):
                output += chr(32 + self.get_pixel(x_pos=x, y_pos=y))
            output += "\n"
        return output

    def render_sprite_to_canvas(self, canvas: Image, palette: List[Tuple[int, int, int]],
                                origin_x: int, origin_y: int,
                                x_pixel_size: int, y_pixel_size: int) -> None:
        """
        Render this sprite onto a PIL Image canvas.

        :param canvas:
            The PIL image canvas to draw onto
        :param palette:
            A list of the RGB components of the colours to associate with each logical colour within the sprite.
        :param origin_x:
            The position of the top-left corner where the sprite should be placed onto the canvas.
        :param origin_y:
            The position of the top-left corner where the sprite should be placed onto the canvas.
        :param x_pixel_size:
            The number of horizontal PIL pixels to cover for each Repton pixel
        :param y_pixel_size:
            The number of vertical PIL pixels to cover for each Repton pixel
        :return:
            None
        """
        for y_pixel in range(self.y_size):
            for x_pixel in range(self.x_size):
                for y_offset in range(y_pixel_size):
                    for x_offset in range(x_pixel_size):
                        value = self.sprite_data[y_pixel][x_pixel]
                        canvas.putpixel((origin_x + x_pixel * x_pixel_size + x_offset,
                                         origin_y + y_pixel * y_pixel_size + y_offset),
                                        palette[value])


class ReptonSpriteSet:
    """
    Class to represent a complete set of sprites in a Repton data file.
    """

    def __init__(self, x_size: int, y_size: int, sprite_count: int):
        """
        Representation of a complete set of sprites in a Repton data file.

        :param x_size:
            Horizontal size of the sprites
        :param y_size:
            Vertical size of the sprites
        :param sprite_count:
            Number of sprites
        """
        self.x_size: int = x_size
        self.y_size: int = y_size
        self.sprite_count: int = sprite_count

        # Initialise the sprites to zeros
        self.sprites: List[ReptonSprite] = [ReptonSprite(x_size=x_size, y_size=y_size) for i in range(sprite_count)]

    @classmethod
    def from_bytes(cls, x_size: int, y_size: int, sprite_count: int,
                   input_bytes: bytes, start_position: int = 0):
        """
        Fetch a set of sprites from binary data.

        :param x_size:
            Horizontal size of the sprites
        :param y_size:
            Vertical size of the sprites
        :param sprite_count:
            Number of sprites
        :param input_bytes:
            Binary data stream
        :param start_position:
            The byte position of the start of the sprites we are to fetch
        :return:
            A ReptonSpriteSet instance
        """

        # Create a sprite set object to read the binary data into
        output = cls(x_size=x_size, y_size=y_size, sprite_count=sprite_count)

        # Number of bytes between consecutive sprites
        sprite_stride = output.sprites[0].sprite_size_bytes()

        # Read each sprite in turn
        for sprite_index in range(sprite_count):
            output.sprites[sprite_index] = ReptonSprite.from_bytes(
                x_size=x_size, y_size=y_size, input_bytes=input_bytes,
                start_position=start_position + sprite_stride * sprite_index
            )

        return output

    def print_sprites_ascii(self, border_size=1) -> str:
        """
        Return a crude representation of this set of sprites in ASCII text.

        :param border_size:
            The size of the border to place around the sprite
        :return:
            ASCII string
        """
        output: str = ""
        for index, sprite in enumerate(self.sprites):
            output += "Sprite {:d}\n".format(index)
            output += sprite.print_sprite_ascii(border_size=border_size)
            output += "\n"
        return output

    def render_sprites_to_canvas(self, canvas: Image, palette: List[Tuple[int, int, int]],
                                 origin_x: int, origin_y: int, margin: int,
                                 x_pixel_size: int, y_pixel_size: int) -> None:
        """
        Render this set of sprites in a horizontal row on a PIL Image canvas.

        :param canvas:
            The PIL image canvas to draw onto
        :param palette:
            A list of the RGB components of the colours to associate with each logical colour within the sprite.
        :param origin_x:
            The position of the top-left corner where the first sprite should be placed onto the canvas.
        :param origin_y:
            The position of the top-left corner where the first sprite should be placed onto the canvas.
        :param margin:
            The horizontal gap to place between the sprites, in units of <x_pixel_size>.
        :param x_pixel_size:
            The number of horizontal PIL pixels to cover for each Repton pixel
        :param y_pixel_size:
            The number of vertical PIL pixels to cover for each Repton pixel
        :return:
            None
        """

        # Horizontal spacing between the left edges of consecutive sprites
        h_stride = (self.sprites[0].x_size + margin) * x_pixel_size

        # Render each sprite in turn
        for index, sprite in enumerate(self.sprites):
            sprite.render_sprite_to_canvas(canvas=canvas, palette=palette,
                                           origin_x=origin_x + h_stride * index,
                                           origin_y=origin_y,
                                           x_pixel_size=x_pixel_size, y_pixel_size=y_pixel_size)


class ReptonLevelMap:
    """
    Class to represent a map of a single Repton level design.
    """

    def __init__(self, x_size: int, y_size: int, metadata: Optional[List[List[str]]] = None):
        """
        Class to represent a map of a single Repton level design.

        :param x_size:
            The horizontal size of the level, in blocks.
        :param y_size:
            The vertical size of the level, in blocks.
        :param metadata:
            List of metadata to associate with this level, contained in an ordered list of [key, value] pairs
        """

        # If there is no metadata, start an empty list
        if metadata is None:
            metadata = []

        self.x_size: int = x_size
        self.y_size: int = y_size
        self.metadata: List[List[str]] = metadata

        # 2D array to hold the level data - initialise to zeros for now
        self.level_data: List[List[int]] = [[0 for x in range(x_size)] for y in range(y_size)]

        # Character ID to place around the edge of the map
        self.border_value: int = 7

        # Default colour palette - this will get overwritten with data from the input file
        self.palette: List[Tuple[int, int, int]] = copy.deepcopy(default_colour_palette)

        # List of teleporters -- list of [from_x, from_y, to_x, to_y]
        self.teleporters: List[List[int, int, int, int]] = []

    @classmethod
    def from_bytes(cls, x_size: int, y_size: int,
                   input_bytes: bytes, start_position: int = 0, encoding_method: int = 1):
        """
        Fetch a single Repton level from binary data.

        :param x_size:
            Horizontal size of the level, in blocks
        :param y_size:
            Vertical size of the level, in blocks
        :param input_bytes:
            Binary data stream
        :param start_position:
            The byte position of the start of the level we are to fetch
        :param encoding_method:
            The encoding method, as described in 'Decoding Repton'
        :return:
            A ReptonLevel instance
        """
        # First read the level data into a 1D array
        level_buffer = []
        level_size = x_size * y_size

        # Byte position in binary file
        p = start_position

        # Read the binary data in groups of five bytes, each encoding eight blocks of level data
        while len(level_buffer) < level_size:
            if encoding_method == 1:
                # Encoding method 1
                level_buffer.append(input_bytes[p] & 0x1F)
                level_buffer.append(((input_bytes[p] + 0x100 * input_bytes[p + 1]) >> 5) & 0x1F)
                level_buffer.append((input_bytes[p + 1] >> 2) & 0x1F)
                level_buffer.append(((input_bytes[p + 1] + 0x100 * input_bytes[p + 2]) >> 7) & 0x1F)
                level_buffer.append(((input_bytes[p + 2] + 0x100 * input_bytes[p + 3]) >> 4) & 0x1F)
                level_buffer.append((input_bytes[p + 3] >> 1) & 0x1F)
                level_buffer.append(((input_bytes[p + 3] + 0x100 * input_bytes[p + 4]) >> 6) & 0x1F)
                level_buffer.append((input_bytes[p + 4] >> 3) & 0x1F)
            else:
                # Encoding method 2
                level_buffer.append((input_bytes[p] >> 3) & 0x1F)
                level_buffer.append(((0x100 * input_bytes[p] + input_bytes[p + 1]) >> 6) & 0x1F)
                level_buffer.append((input_bytes[p + 1] >> 1) & 0x1F)
                level_buffer.append(((0x100 * input_bytes[p + 1] + input_bytes[p + 2]) >> 4) & 0x1F)
                level_buffer.append(((0x100 * input_bytes[p + 2] + input_bytes[p + 3]) >> 7) & 0x1F)
                level_buffer.append((input_bytes[p + 3] >> 2) & 0x1F)
                level_buffer.append(((0x100 * input_bytes[p + 3] + input_bytes[p + 4]) >> 5) & 0x1F)
                level_buffer.append(input_bytes[p + 4] & 0x1F)

            # Advance to next set of five bytes
            p += 5

        # Turn 1D array into a 2D array mapping the level
        output = cls(x_size=x_size, y_size=y_size)
        for y in range(y_size):
            for x in range(x_size):
                output.level_data[y][x] = level_buffer[y * x_size + x]
        return output

    def level_size_bytes(self) -> int:
        """
        Fetch the number of binary bytes, needed to store this level in a binary file.
        :return:
            Number of bytes.
        """
        return int(self.x_size * self.y_size * 5 / 8)

    def get_block(self, x_pos: int, y_pos: int) -> int:
        """
        Fetch a single block from a level design.
        :param x_pos:
            The horizontal position of the block to query.
        :param y_pos:
            The vertical position of the block to query.
        :return:
            Block contents (0-32)
        """
        if (0 <= x_pos < self.x_size) and (0 <= y_pos < self.y_size):
            return self.level_data[y_pos][x_pos]
        else:
            return self.border_value

    def print_map_ascii(self, border_size=1) -> str:
        """
        Return a crude representation of this Repton level in ASCII text.

        :param border_size:
            The size of the border to place around the level
        :return:
            ASCII string
        """
        output = ""
        for y in range(-border_size, self.y_size + border_size):
            for x in range(-border_size, self.x_size + border_size):
                output += chr(32 + self.get_block(x_pos=x, y_pos=y))
            output += "\n"
        return output

    def render_map_to_canvas(self, canvas: Image, sprites: ReptonSpriteSet,
                             origin_x: int, origin_y: int,
                             x_pixel_size: int, y_pixel_size: int, border_size=1) -> None:
        """
        Render this level onto a PIL Image canvas.

        :param canvas:
            The PIL image canvas to draw onto
        :param origin_x:
            The position of the top-left corner where the level should be placed onto the canvas.
        :param origin_y:
            The position of the top-left corner where the level should be placed onto the canvas.
        :param x_pixel_size:
            The number of horizontal PIL pixels to cover for each Repton pixel
        :param y_pixel_size:
            The number of vertical PIL pixels to cover for each Repton pixel
        :param border_size:
            The size of the border to place around the level
        :return:
            None
        """

        # Render blocks
        h_stride = sprites.sprites[0].x_size * x_pixel_size
        v_stride = sprites.sprites[0].y_size * y_pixel_size
        for y in range(-border_size, self.y_size + border_size):
            for x in range(-border_size, self.x_size + border_size):
                v = self.get_block(x_pos=x, y_pos=y)
                sprites.sprites[v].render_sprite_to_canvas(canvas=canvas, palette=self.palette,
                                                           origin_x=origin_x + h_stride * x,
                                                           origin_y=origin_y + v_stride * y,
                                                           x_pixel_size=x_pixel_size, y_pixel_size=y_pixel_size)

        # Label teleporters with letters
        draw = ImageDraw.Draw(canvas)
        font_search = font_manager.FontProperties(family='sans-serif', weight='black')
        font_file = font_manager.findfont(font_search)
        font = ImageFont.truetype(font_file, 14 * y_pixel_size)
        teleport_margin_x = h_stride / 2 - 7 * y_pixel_size
        teleport_margin_y = v_stride / 2 - 7 * y_pixel_size

        for teleport_index, item in enumerate(self.teleporters):
            from_x, from_y, to_x, to_y = item
            if from_x > self.x_size:
                continue

            text = chr(65 + teleport_index)
            draw.text((origin_x + h_stride * from_x + teleport_margin_x,
                       origin_y + v_stride * from_y + teleport_margin_y),
                      text, font=font, fill=(128, 128, 128), stroke_width=1, stroke_fill=(0, 0, 0), align="center")
            draw.text((origin_x + h_stride * to_x + teleport_margin_x,
                       origin_y + v_stride * to_y + teleport_margin_y),
                      text, font=font, fill=(0, 220, 0), align="center")


class ReptonLevelSet:
    """
    Class to represent a complete set of Repton levels contained in a data file.
    """

    def __init__(self, x_size: int, y_size: int, level_count: int):
        """
        Class to represent a complete set of Repton levels contained in a data file.

        :param x_size:
            The horizontal size of the level, in blocks.
        :param y_size:
            The vertical size of the level, in blocks.
        :param level_count:
            The number of levels in the data file.
        """
        self.x_size: int = x_size
        self.y_size: int = y_size
        self.level_count: int = level_count

        # Initialise all the levels to zeros for now.
        self.levels: List[ReptonLevelMap] = [ReptonLevelMap(x_size=x_size, y_size=y_size) for i in range(level_count)]

    @classmethod
    def from_bytes(cls, x_size: int, y_size: int, level_count: int,
                   input_bytes: bytes, start_position: int = 0,
                   level_stride: Optional[int] = None, encoding_method: int = 1):
        """
        Fetch a set of Repton levels from binary data.

        :param x_size:
            Horizontal size of each level, in blocks
        :param y_size:
            Vertical size of each level, in blocks
        :param input_bytes:
            Binary data stream
        :param start_position:
            The byte position of the start of the first level we are to fetch
        :param level_stride:
            The number of bytes separating the start positions of successive levels.
        :param encoding_method:
            The encoding method, as described in 'Decoding Repton'
        :return:
            A ReptonLevelSet instance
        """
        # Instantiate a set a empty level data
        output = cls(x_size=x_size, y_size=y_size, level_count=level_count)

        # If the level_stride was not specified, assume it is the size of each level map in bytes
        if level_stride is None:
            level_stride = output.levels[0].level_size_bytes()

        # Read each level in turn
        for level_index in range(level_count):
            output.levels[level_index] = ReptonLevelMap.from_bytes(
                x_size=x_size, y_size=y_size, input_bytes=input_bytes, encoding_method=encoding_method,
                start_position=start_position + level_stride * level_index
            )

        return output

    def print_maps_ascii(self, border_size=1) -> str:
        """
        Return a crude representation of this set of Repton levels in ASCII text.

        :param border_size:
            The size of the border to place around each level
        :return:
            ASCII string
        """
        output: str = ""
        for index, level in enumerate(self.levels):
            output += "Level {:d}\n".format(index + 1)
            output += level.print_map_ascii(border_size=border_size)
            output += "\n"
        return output


class ReptonDataFile:
    """
    Class to represent the complete contents of a Repton data file.
    """

    def __init__(self,
                 sprites: Optional[ReptonSpriteSet] = None,
                 sprites_maps: Optional[ReptonSpriteSet] = None,
                 level_maps: Optional[ReptonLevelSet] = None,
                 scaling_x: int = 2,
                 scaling_y: int = 1
                 ):
        self.sprites: Optional[ReptonSpriteSet] = sprites
        self.sprites_maps: Optional[ReptonSpriteSet] = sprites_maps
        self.level_maps: Optional[ReptonLevelSet] = level_maps
        self.scaling_x = scaling_x
        self.scaling_y = scaling_y


def render_repton_maps(output_filename: str, data: ReptonDataFile,
                       margin_sprites: int = 1, margin_map: int = 3,
                       scaling_x: int = 1, scaling_y: int = 1) -> None:
    """
    Render a PNG representation of all the maps and sprites in a Repton data file.
    
    :param output_filename: 
        Filename for output PNG file
    :param data: 
        The data read from the binary data file
    :param margin_sprites: 
        The margin between the row of sprites, scaled Repton pixels
    :param margin_map: 
        The margin between the level maps, blocks
    :param scaling_x:
        The horizontal magnification factor to apply to all Repton graphics
    :param scaling_y:
        The vertical magnification factor to apply to all Repton graphics
    :return: 
        None
    """
    # Size of each Repton pixel in the PNG file
    y_pixel_size: int = scaling_y
    x_pixel_size: int = scaling_x

    # Dimensions of each Repton level map in PNG pixels
    levels_origin_x: int = margin_sprites
    levels_origin_y: int = margin_sprites
    level_x_size: int = 0
    level_y_size: int = 0
    level_count: int = 0

    # Make sure we have a set of sprites of work with
    if data.sprites is not None:
        sprites: ReptonSpriteSet = data.sprites
    else:
        sprites = read_repton_infinity_file(filename=default_repton_infinity_sprites, flavour="eS").sprites
    sprites_x_size: int = sprites.sprites[0].x_size
    sprites_y_size: int = sprites.sprites[0].y_size

    # Calculate the size of each level map in pixels
    if data.level_maps is not None:
        levels_origin_x = 40 * x_pixel_size
        levels_origin_y = 40 * y_pixel_size
        level_x_size = (data.level_maps.levels[0].x_size + margin_map) * sprites_x_size * x_pixel_size
        level_y_size = (data.level_maps.levels[0].y_size + margin_map) * sprites_y_size * y_pixel_size
        level_count = data.level_maps.level_count

    # Calculate size of row of sprite images
    sprites_origin_x: int = levels_origin_x
    sprites_origin_y: int = levels_origin_y + level_y_size * ceil(level_count / 2)

    sprite_row_x_size: int = sprites.sprite_count * (sprites_x_size + margin_sprites) * x_pixel_size
    sprite_row_y_size: int = (sprites_y_size + margin_sprites) * y_pixel_size

    # Calculate size of row of map sprite images
    sprites_map_origin_x: int = levels_origin_x
    sprites_map_origin_y: int = sprites_origin_y + sprites_y_size + margin_sprites
    sprites_map_margin: int = 0
    if data.sprites_maps is not None:
        sprites_map_x_size: int = data.sprites_maps.sprites[0].x_size
        # Align map sprites horizontally below larger sprites in row above
        sprites_map_margin = sprites_x_size + margin_sprites - sprites_map_x_size
        # Make sure map sprites are centre aligned
        sprites_map_origin_x += (sprites_x_size - sprites_map_x_size) // 2

    # Calculate bounding box of the PNG image we will generate
    output_size_x = max(levels_origin_x + level_x_size * 2, sprites_origin_x + sprite_row_x_size)
    output_size_y = sprites_map_origin_y + sprite_row_y_size + margin_sprites

    # Create image
    map_image = Image.new('RGB', (output_size_x, output_size_y), (0, 0, 0))

    # Make sure we have a colour scheme to use
    if data.level_maps is not None:
        palette = data.level_maps.levels[0].palette
    else:
        palette = copy.deepcopy(default_colour_palette)

    # Paint row of sprites
    sprites.render_sprites_to_canvas(
        canvas=map_image, palette=palette,
        origin_x=sprites_origin_x, origin_y=sprites_origin_y, margin=margin_sprites,
        x_pixel_size=x_pixel_size, y_pixel_size=y_pixel_size
    )

    # Paint row of map sprites
    if data.sprites_maps is not None:
        data.sprites_maps.render_sprites_to_canvas(
            canvas=map_image, palette=palette,
            origin_x=sprites_map_origin_x, origin_y=sprites_map_origin_y, margin=sprites_map_margin,
            x_pixel_size=x_pixel_size, y_pixel_size=y_pixel_size
        )

    # Paint levels
    for index in range(level_count):
        origin_x = levels_origin_x + level_x_size * (index % 2)
        origin_y = levels_origin_y + level_y_size * (index // 2)
        data.level_maps.levels[index].render_map_to_canvas(
            canvas=map_image, origin_x=origin_x, origin_y=origin_y,
            sprites=sprites, x_pixel_size=x_pixel_size, y_pixel_size=y_pixel_size
        )

    # Save the final image
    map_image.save(output_filename, "PNG")


def read_repton3_map(filename: str, sprites_x_size: int, sprites_y_size: int) -> ReptonDataFile:
    """
    Read a binary Repton 3 design file

    :param filename:
        The filename of the input binary file
    :param sprites_x_size:
        The horizontal number of pixels in each sprite (differs between BBC Micro and Electron versions)
    :param sprites_y_size:
        The vertical number of pixels in each sprite (differs between BBC Micro and Electron versions)
    :return:
        ReptonDataFile
    """
    # Read the input binary data
    with open(filename, "rb") as f_in:
        file_bytes: bytes = f_in.read()

    # Number of levels in each data file
    level_count = 8

    # Read the Repton 3 sprites
    sprites: ReptonSpriteSet = ReptonSpriteSet.from_bytes(x_size=sprites_x_size, y_size=sprites_y_size,
                                                          sprite_count=48,
                                                          input_bytes=file_bytes, start_position=0xE20)

    # Read the Repton 3 levels
    level_maps: ReptonLevelSet = ReptonLevelSet.from_bytes(x_size=28, y_size=24, level_count=level_count,
                                                           input_bytes=file_bytes, start_position=0x100,
                                                           encoding_method=1)

    # Read the list of teleporters - 4 per level
    for level_index in range(level_count):
        teleporters_start = 0x60 + 0x10 * level_index
        for teleport_index in range(4):
            from_x: int = file_bytes[teleporters_start + teleport_index * 4 + 0]
            from_y: int = file_bytes[teleporters_start + teleport_index * 4 + 1]
            to_x: int = file_bytes[teleporters_start + teleport_index * 4 + 2]
            to_y: int = file_bytes[teleporters_start + teleport_index * 4 + 3]
            level_maps.levels[level_index].teleporters.append([from_x, from_y, to_x, to_y])

    # Read the palette from a Repton 3 design file
    palette_start = 0xE0
    for level_index in range(level_count):
        for colour_index in range(4):
            colour_code: int = file_bytes[palette_start + 4 * level_index + colour_index]
            level_maps.levels[level_index].palette[colour_index] = bbc_micro_colours[colour_code]

    return ReptonDataFile(sprites=sprites, level_maps=level_maps)


def read_repton3_map_electron(filename: str) -> ReptonDataFile:
    """
    Read a binary Repton 3 design file (Electron version)

    :param filename:
        The filename of the input binary file
    :return:
        ReptonDataFile
    """
    return read_repton3_map(filename, sprites_x_size=12, sprites_y_size=24)


def read_repton3_map_bbc(filename: str) -> ReptonDataFile:
    """
    Read a binary Repton 3 design file (BBC Micro version)

    :param filename:
        The filename of the input binary file
    :return:
        ReptonDataFile
    """
    return read_repton3_map(filename, sprites_x_size=16, sprites_y_size=32)


def read_repton_infinity_file(filename: str, flavour: str) -> ReptonDataFile:
    """
    Read a binary Repton Infinity design file (BBC Micro or Electron versions)

    :param filename:
        The filename of the input binary file
    :param flavour:
        The type of input file: G, M, S, E, eG, eM, eS, eE
    :return:
        ReptonDataFile
    """
    # Fetch information about this flavour of input file
    assert flavour in repton_infinity_file_structure
    structure: dict = repton_infinity_file_structure[flavour]

    # Read the binary input file
    with open(filename, "rb") as f_in:
        file_bytes: bytes = bytearray(f_in.read())

    # Remove encryption, if necessary
    if structure['encrypted']:
        for index in range(len(file_bytes)):
            key = (-3 * index) & 0xFF
            file_bytes[index] ^= key

    # Read the Repton Infinity sprites
    sprites: Optional[ReptonSpriteSet] = None
    if structure['sprites_start'] is not None:
        sprites = ReptonSpriteSet.from_bytes(x_size=structure['sprite_dimensions'][0],
                                             y_size=structure['sprite_dimensions'][1],
                                             sprite_count=48,
                                             input_bytes=file_bytes,
                                             start_position=structure['sprites_start'])

    # Read the Repton Infinity map sprites
    sprites_maps: Optional[ReptonSpriteSet] = None
    if structure['map_sprites_start'] is not None:
        sprites_maps = ReptonSpriteSet.from_bytes(x_size=structure['map_sprite_dimensions'][0],
                                                  y_size=structure['map_sprite_dimensions'][1],
                                                  sprite_count=32,
                                                  input_bytes=file_bytes,
                                                  start_position=structure['map_sprites_start'])

    # Read the Repton Infinity levels
    level_maps: Optional[ReptonLevelSet] = None
    if structure['levels_start'] is not None:
        level_maps = ReptonLevelSet.from_bytes(x_size=32, y_size=24,
                                               level_count=structure['level_count'],
                                               input_bytes=file_bytes, start_position=structure['levels_start'],
                                               level_stride=0x200, encoding_method=2)

        # Read the list of teleporters from the map data
        for level_index in range(level_maps.level_count):
            teleporters_start = structure['levels_start'] + 0x200 * level_index + 0x1E0
            for teleport_index in range(6):
                teleport_bytes = file_bytes[teleporters_start + teleport_index * 4:
                                            teleporters_start + teleport_index * 4 + 4]
                from_x: int = (teleport_bytes[0] + teleport_bytes[1] * 0x100) % 32
                from_y: int = (teleport_bytes[0] + teleport_bytes[1] * 0x100) // 32
                to_x: int = (teleport_bytes[2] + teleport_bytes[3] * 0x100) % 32
                to_y: int = (teleport_bytes[2] + teleport_bytes[3] * 0x100) // 32
                level_maps.levels[level_index].teleporters.append([from_x, from_y, to_x, to_y])

        # Read the palette for each level from a Repton Infinity design file
        for level_index in range(level_maps.level_count):
            palette_start = structure['levels_start'] + 0x200 * level_index + 0x1FC
            for colour_index in range(4):
                colour_code: int = file_bytes[palette_start + colour_index]
                level_maps.levels[level_index].palette[colour_index] = bbc_micro_colours[colour_code]

    output: ReptonDataFile = ReptonDataFile(sprites=sprites, sprites_maps=sprites_maps, level_maps=level_maps)

    if 'square_pixels' in structure and structure['square_pixels']:
        output.scaling_y = output.scaling_x

    return output

def render_repton_data_file(input: str, flavour: str, output_filename: str) -> None:
    """
    Render a PNG representation of a Repton data file.

    :param input:
        The filename of the Acorn binary input file.
    :param flavour:
        The type of input file.
    :param output_filename:
        The filename for the output PNG image.
    """
    # Read the binary input file
    repton_data: Optional[ReptonDataFile] = None

    if flavour == "repton3_electron":
        repton_data = read_repton3_map_electron(filename=input)
    elif flavour == "repton3_bbc":
        repton_data = read_repton3_map_bbc(filename=input)
    elif flavour.startswith("repton_infinity_"):
        repton_data = read_repton_infinity_file(filename=input, flavour=flavour.split("_")[-1])

    # Render level maps to a PNG file
    magnification = 1
    render_repton_maps(output_filename=output_filename, data=repton_data, margin_sprites=3,
                       scaling_x=magnification * repton_data.scaling_x,
                       scaling_y=magnification * repton_data.scaling_y)


# Do it right away if we're run as a script
if __name__ == "__main__":
    # Set up a logging object
    logging.basicConfig(level=logging.INFO,
                        stream=sys.stdout,
                        format='[%(asctime)s] %(levelname)s:%(filename)s:%(message)s',
                        datefmt='%d/%m/%Y %H:%M:%S')
    logger = logging.getLogger(__name__)
    logger.debug(__doc__.strip())

    # Read input parameters
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('--input',
                        default="/tmp/foob/PRELUDE",
                        type=str,
                        dest="input",
                        help="The Repton level file to produce maps for")
    parser.add_argument('--version',
                        default="repton3_electron",
                        type=str,
                        choices=["repton1_electron", "repton1_bbc",
                                 "repton2_electron", "repton2_bbc",
                                 "repton3_electron", "repton3_bbc",
                                 "repton_infinity_G", "repton_infinity_M", "repton_infinity_S", "repton_infinity_E",
                                 "repton_infinity_eG", "repton_infinity_eM", "repton_infinity_eS", "repton_infinity_eE",
                                 ],
                        dest="version",
                        help="The version of Repton that generated the input data file")
    parser.add_argument('--output',
                        default="/tmp/foo.png",
                        type=str,
                        dest="output",
                        help="The filename for the output PNG image we should generate")
    parser.set_defaults(prg=False)
    args = parser.parse_args()

    # Render output
    render_repton_data_file(input=args.input, flavour=args.version, output_filename=args.output)
